---
title: "Submodels"
---

# *Submodels function*

*This is the main function in the submodels family.*

```{r, message=FALSE, warning=FALSE}
library(tidyverse)

library(MASS)
library(Hmisc)
library(lme4)
library(mi)
library(doSNOW)
library(pROC)
`%notin%`=Negate(`%in%`) #I think that you can do !x %in% y and one day I will start doing that

```

-   *To do: work out what libraries can be deleted*

```{r, message=FALSE}

submodels<- function(DATA, model, model_fn,submodel_type=c("pmks", "ccsm"), force_variables=c(),remove_model_data=c("model", "y", "fitted"), ...){
  #DATA=the training data
  #model = the model as a string
  #model_fn= the function for the model being used
  #force_varaibles = Any variables that you want to force into the model
  # remove_subject_data is to remve the ipd from the model
  submodel_type=match.arg(submodel_type)
  
  mod.DATA<- get_all_vars(as.formula(model), data=DATA) %>% drop_na(,1) %>% drop_na(all_of(force_variables))
  
  SDATA<- mod.DATA[,-1] #remove the outcome 
  var_names=names(SDATA)
  unpack(missingness_pattern(SDATA))
  # tmp.dat      <- as.data.frame(is.na(SDATA)*1)
  # tmp.pattern  <- factor(apply(tmp.dat,1,function(z) paste(z,collapse="")))
  # 
  # 
  # tmp.info     <- split(seq(nrow(SDATA)), tmp.pattern)
  # mp.levels    <- levels(tmp.pattern)
  # mp.pattern   <- do.call(rbind, lapply(as.list(mp.levels),function(ZZ) strsplit(ZZ,'')[[1]])) 		
  # mp.info     <- data.frame(cbind(names(tmp.info), unlist(lapply(tmp.info, length))),
  #                           stringsAsFactors= FALSE)
  # rownames(mp.info) <- seq(nrow(mp.info))
  # colnames(mp.info) <- c('mp','n')
  
  all.patterns0=expand.grid(rep(list(0:1),ncol(SDATA)))
  names(all.patterns0)=var_names
  #stops the computing of models that would have dropped the force variables.
  remove=intersect(var_names, force_variables)
  all.patterns1=all.patterns0[rowSums(as.matrix(all.patterns0[,remove]==1))==0,]
  all.patterns <- factor(apply(all.patterns1,1,function(z) paste(z,collapse="")))
  obs.patterns <- unique(tmp.pattern)
  
  
  if(length(setdiff(all.patterns,obs.patterns)) == 0){
    empty.patterns = NULL
  } else {
    empty.patterns <- data.frame(mp = factor(setdiff(all.patterns,obs.patterns)), n=0)
  }	
  mp.info <- rbind(mp.info,empty.patterns)
  
  
  unpack(model_breakdown(model))
  
  
  cc <- ncol(model.matrix(as.formula(model),mod.DATA))
  
  threshold <- cc*2
  mp.info$use.ptmx <- (as.numeric(mp.info$n)>=threshold)*1
  
  reg.out <- vector('list', length(all.patterns))
  names(reg.out) <- mp.info$mp.info
  
  
  for(ixx in seq(nrow(mp.info))) {
    col.keep  <- which(strsplit(mp.info$mp[ixx],'')[[1]]=='0')
    if(length(col.keep)==0){
      new.mod <- paste(mod.lhs,1,sep='~')
    } else {
      new.mod   <- paste(mod.lhs,paste(mod.rhs[col.keep],collapse='+'),
                         sep='~')
    }
    #adding in the interaction term
    if(length(mod.rhs.interaction>0)){
      for(i in 1:length(mod.rhs.interaction))
        new.mod=gsub(gsub("\\*","\\\\+",mod.rhs.interaction[i]), mod.rhs.interaction[i], new.mod)
    }
    new.mod=as.formula(new.mod)
    
    # print(class(DATA$eos_bl))
    if(mp.info$use.ptmx[ixx]==1&submodel_type=="pkms"){
      
      reg.out[[ixx]] <- list(pattern = mod.rhs[col.keep],
                             mod = model_fn(formula=new.mod,data=mod.DATA[tmp.info[[ixx]],]))
    }else{
      
      reg.out[[ixx]] <- list(pattern = mod.rhs[col.keep],
                             mod	 = model_fn(formula=new.mod,data=mod.DATA))
      
    }

    
    for(i in remove_model_data){
      reg.out[[ixx]][["mod"]][[i]]=NULL
    }
  }
  reg.out[["meta"]][["model"]]=model
  reg.out[["meta"]][["vars"]]=var_names
  reg.out[["meta"]][["force_variables"]]=force_variables
  reg.out[["meta"]][["mp.info"]]=mp.info
  reg.out[["meta"]][["all.patterns"]]=all.patterns
  reg.out[["meta"]][["submodel_type"]]=submodel_type
  
  return(reg.out)
}

```
