---
title: "C for benefit"
bibliography: references.bib
---

In C for benefit, the matching is based on predicted benefit, but what happens when there are substantially different baseline 'hetrogeneous' risks? This is based on @klaveren2018 which used a logistic model.

#### Lit review

It appears from @klaveren2018 that (assuming equal number in each group; in a case of unequal numbers extra people are removed at random), each arm is ranked on predicted treatment benefit. We take $rank(\beta_{het,i})$ in each arm and rank 1 in treatment is paired with rank 1 in control, two with two etc.

Where there is a large homogeneous/baseline effect (that is the outcome is caused in large part by factor(s) that do not interact with treatment), the means that we may end up matching patients with equal/very similar

@efthimiou2023 add that C4B can be used by matching on covariates or on the predicted benefit. In a further paper by @hoogland2024 discuss matching on covariates (via mahlinobis distance) but in high dimensional data, this yields issues. @klaveren2018 briefly mentioned using MD as a sensitivity analysis but didn't go into further detail. @smit2025 used a version called AUC-benefit although the definition was a tad ropey and didn't use C4B as they didn't like the matching.

### Model decomposition

Let's consider a model

$$
Y \sim X_1 + X_2 + arm * X_3 + arm * X_4 
$$

This can be rewritten as

$$
y_i= f(\beta_0 + \beta_1 x_{1i} + \beta_2 x_{2i} + \beta_3 x_{3i} + \beta_4 x_{4i} + arm_i*(\beta_a + \beta_{3a} x_{3i} + \beta_{4a} x_{4i}), ...) 
$$

where $...$ is other arguments as required. This can subsequently reduce

$$
y_i=f(\beta_0+ \beta_a arm_i+\beta_{homo,i}+\beta_{het,i}arm_i,...)
$$

$$
\beta_{homo,i}=\beta_1 x_{1i} + \beta_2 x_{2i} + \beta_3 x_{3i} + \beta_4 x_{4i}
$$

$$
\beta_{het,i}= \beta_{3a} x_{3i} + \beta_{4a} x_{4i}
$$

So in the case where $\beta_a \gg \beta_{het,i}$ and $\beta_{homo,i} \gg \beta_{het,i}$ , this reduces to essentially a homogeneous model and C-for-benefit doesn't really apply. We will further consider only when $\beta_{het,i}$ is non-negligible. This does apply to larger and more complex models but we use this model wlog. $\beta_0$ can be folded into $\beta_{homo,i}$ and $\beta_{arm}$ can be folded into $\beta_{het,i}$ as they shift the values equally for all patients.

Previous literature has generally used logistic regression with the ternary outcome (-1,0,1) corresponding to harm, no difference, and benefit respectively. In this analysis we extend the paired outcome to calculated as $actual_{trt,j}-actual_{control,j}$ where j is the $j^{th}$ matched pair. \<0 corresponds to harm and \>0 corresponds to benefit.

### Matching procedure

#### Option 1: Distance between the het and the homo

After reducing the model down to our homo- and hetrogeneous effects, we can match the patients using some distance metric.

A benefit of this is that the data can be shifted (e.g., folding in the intercept) and that it does not affect the match. The downside of this is that you cannot weight the data.

When calculating C4B you rank the difference in the actual outcome and the rank of the mean hetro value.

#### Option 2: Excess exacerbations

-   Matching only on the rank of the heterogeneous estimate

-   We calculate the excess exacerbations based on $actual_i-\mathbb{E}(exac_i|arm_i=control)$

-   In the case of a pt in the control arm in real life then it would be the difference between predicted and actual

-   In the case of pt in the trt group then the excess captures the treatment effect

-   You then calculate the C4B based on the $excess\sim rank(hetro)$.

    -   In this case the hetro values are likely to be a lot closer than when using homo as part of the match.

-   This will only work for count or linear models.

#### A side note on Random Forests

If we were to use the stratified random forests (the proper name I have forgotten), then $\beta_{homo}$ is the value of the control tree and the $\beta_{het}$ is the difference in the trees.

### Implementation {#sec-implement}

```{r, echo=FALSE, message=FALSE, warning=FALSE}
load("C:\\Users\\mbbx4sb5\\Dropbox (The University of Manchester)\\00_ICS_RECODE_Shared\\data/study_data.RDa")
set.seed(121)
data1=study_data$EFFECT$ad
data1$train=as.logical(rbinom(nrow(data1),1, 0.8))

data=data1
```

```{r, message=FALSE, warning=FALSE}
library(MASS)
library(tidyverse)

# Data loaded out of sight
train=data %>% filter(train)
test=data %>% filter(!train)
formula=exac_modsev_n ~ arm_ipd*eos_bl+age_imp+exac_bl+sex+arm_ipd*smoking_bl+fev1_bl+offset(trt_dur)

model=glm.nb(formula, train, contrasts=NULL)

summary(model)

```

**Concordance in train**

```{r, message=FALSE, warning=FALSE}
#finding the rate adjusted concordance
train %>% 
  cbind.data.frame(pred=predict(model, newdata = train, type="response")) %>%
  mutate(rate=exac_modsev_n/trt_dur,
         rate_p=pred/trt_dur) %>% 
  lm(rate~rate_p, data=.) %>% 
  survival::concordance()


```

**Concordance in test**

```{r, message=FALSE, warning=FALSE}
test %>% 
  cbind.data.frame(pred=predict(model, newdata = test, type="response")) %>%
  mutate(rate=exac_modsev_n/trt_dur,
         rate_p=pred/trt_dur) %>% 
  lm(rate~rate_p, data=.) %>% 
  survival::concordance()
  
```

FWIW this is a weird trial that has almost no ICS effect.

#### Model decomposition

```{r}
decompose_model <- function(model, var, newdata=NULL, leave_var_as_binary=F) {
  
  model_data <- model$model
  var0=var
  levels=levels(model_data[[var0]])
  var=paste0(var0,levels[2])
  
  
  coeffs <- coef(model)
  
  if(is.null(newdata)){
    X <- model.matrix(model)
  }else{
    X <- model.matrix(model, data=newdata)
  }
  coeff_names <- names(coeffs)
  
  # Identify components
  homo_terms <- coeff_names[!grepl(paste0(var, ":"), coeff_names) & coeff_names != var]
  hetro_terms <- coeff_names[grepl(paste0(var, ":"), coeff_names)]
  
  # Calculate homo component (as before)
  homo_comp <- X[, homo_terms, drop = FALSE] %*% coeffs[homo_terms]
  
  # For hetro component: get the base terms without multiplying by var
  # Extract the hetro coefficients and multiply by the base variables only
  hetro_comp <- rep(0, nrow(X))
  
  for(term in hetro_terms) {
    # Get the base variable name (remove "var:" prefix)
    base_var <- gsub(paste0(var, ":"), "", term)
    # Multiply coefficient by base variable only (not by var)
    hetro_comp <- hetro_comp + coeffs[term] * X[, base_var]
  }
  
  # Handle var main effect - add it to hetro component
  if(var %in% coeff_names) {
    hetro_comp <- hetro_comp + coeffs[var]
  }
  
  # Extract the var data
  var_data <- X[, var]
  
  out=data.frame(
    homo = as.vector(homo_comp),
    hetro = as.vector(hetro_comp),
    var = as.vector(var_data)
  )
  colnames(out)[3] <- var0
  
  if(!leave_var_as_binary){
    out[[var0]] <- ifelse(out[[var0]] == 1, levels[2], levels[1])
  }
  
  if(!is.null(attr(model$terms, "offset"))){
    
    offset_name=(model %>% formula %>% all.vars())[attr(model$terms, "offset")]
    
    if(is.null(newdata)){
      offset=model$offset
    }else{
      offset=newdata[[offset_name]]
    }
    
    out[[offset_name]]=offset
  }
  return(out)
}

# Usage
result <- decompose_model(model, "arm_ipd", leave_var_as_binary = T)
head(result)

test=data %>% filter(!train)
result2 <- decompose_model(model, "arm_ipd", newdata=test, leave_var_as_binary = T)
head(result2)
```

#### Option 1

```{r}
library(MatchIt)
result_pre_match=result %>% 
  mutate(rn=row_number()) %>% 
  cbind.data.frame("exac_modsev_n"=train$exac_modsev_n)

set.seed(123)
min_size <- result_pre_match %>%
  group_by(arm_ipd) %>%
  summarise(n = n()) %>%
  pull(n) %>%
  min()

result_balanced <- result_pre_match %>%
  group_by(arm_ipd) %>%
  sample_n(min_size, replace = F) %>%
  ungroup() %>% 
  arrange(rn)

# Perform full matching
m.out <- matchit(arm_ipd ~ homo + hetro,
                 data = result_balanced,
                 method = "optimal",
                 ratio = 1,
                 replace = FALSE)

# Get matched data with subclass info
matched_data <- match.data(m.out)

# Show who is matched together (by subclass)
matched_groups <- matched_data %>%
  dplyr::select(subclass, arm_ipd, everything()) %>%
  arrange(subclass)%>% 
  mutate(arm_ipd=if_else(arm_ipd==0, "ICS", "Control"))

#showing that density is preserved
matched_groups %>% 
  ggplot(aes(x=hetro, group=arm_ipd, col=arm_ipd))+
  geom_density()

matched_groups %>%
  ggplot(aes(x = hetro, y = homo, group = subclass, colour=arm_ipd)) +
  geom_line(color = "black") +
  geom_point()+
  labs(colour="Arm")+
  theme_classic()

### C4B 
result_pre_match %>% merge(matched_data %>% dplyr::select(rn, hetro, subclass), .by="rn") %>% 
mutate(rate=exac_modsev_n/trt_dur) %>% 
  mutate(mean_het=mean(hetro), .by=subclass)%>% 
  dplyr::select(rate, subclass, mean_het, arm_ipd) %>%
  mutate(arm_ipd=if_else(arm_ipd==0, "ICS", "Control")) %>% 
  pivot_wider(names_from = arm_ipd, values_from = rate) %>% 
  mutate(diff=ICS-Control) %>% 
  lm(diff~mean_het, data=.) %>% 
  survival::concordance()


```

##### Validation

```{r}
library(MatchIt)
result_pre_match=result2 %>% 
  mutate(rn=row_number()) %>% 
  cbind.data.frame("exac_modsev_n"=test$exac_modsev_n)

set.seed(124)
min_size <- result_pre_match %>%
  group_by(arm_ipd) %>%
  summarise(n = n()) %>%
  pull(n) %>%
  min()

result_balanced <- result_pre_match %>%
  group_by(arm_ipd) %>%
  sample_n(min_size, replace = F) %>%
  ungroup() %>% 
  arrange(rn)

# Perform full matching
m.out <- matchit(arm_ipd ~ homo + hetro,
                 data = result_balanced,
                 method = "optimal",
                 ratio = 1,
                 replace = FALSE)

# Get matched data with subclass info
matched_data <- match.data(m.out)

# Show who is matched together (by subclass)
matched_groups <- matched_data %>%
  dplyr::select(subclass, arm_ipd, everything()) %>%
  arrange(subclass)%>% 
  mutate(arm_ipd=if_else(arm_ipd==0, "ICS", "Control"))

#showing that density is preserved
matched_groups %>% 
  ggplot(aes(x=hetro, group=arm_ipd, col=arm_ipd))+
  geom_density()

matched_groups %>%
  ggplot(aes(x = hetro, y = homo, group = subclass, colour=arm_ipd)) +
  geom_line(color = "black") +
  geom_point()+
  labs(colour="Arm")+
  theme_classic()


### C4B 
result_pre_match %>% merge(matched_data %>% dplyr::select(rn, hetro, subclass), .by="rn") %>% 
mutate(rate=exac_modsev_n/trt_dur) %>% 
  mutate(mean_het=mean(hetro), .by=subclass)%>% 
  dplyr::select(rate, subclass, mean_het, arm_ipd) %>%
  mutate(arm_ipd=if_else(arm_ipd==0, "ICS", "Control")) %>% 
  pivot_wider(names_from = arm_ipd, values_from = rate) %>% 
  mutate(diff=ICS-Control) %>% 
  lm(diff~mean_het, data=.) %>% 
  survival::concordance()


```

#### Option 2

```{r}
library(MatchIt)
result_pre_match=result %>% 
  mutate(rn=row_number()) %>% 
  cbind.data.frame("exac_modsev_n"=train$exac_modsev_n)

set.seed(123)
min_size <- result_pre_match %>%
  group_by(arm_ipd) %>%
  summarise(n = n()) %>%
  pull(n) %>%
  min()

result_balanced <- result_pre_match %>%
  group_by(arm_ipd) %>%
  sample_n(min_size, replace = F) %>%
  ungroup() %>% 
  arrange(rn)

result_excess=result_balanced %>% 
  mutate(excess=exac_modsev_n/trt_dur-exp(homo))


# Perform full matching
m.out <- matchit(arm_ipd ~ hetro,
                 data = result_excess,
                 method = "optimal",
                 ratio = 1,
                 replace = FALSE)

# Get matched data with subclass info
matched_data <- match.data(m.out)

# Show who is matched together (by subclass)
matched_groups <- matched_data %>%
  dplyr::select(subclass, arm_ipd, everything()) %>%
  arrange(subclass)%>% 
  mutate(arm_ipd=if_else(arm_ipd==0, "ICS", "Control"))

matched_groups %>%
  ggplot(aes(x = arm_ipd, y = hetro, group = subclass, colour=arm_ipd)) +
  geom_line(color = "black") +
  geom_point()+
  labs(colour="Arm")+
  theme_classic()


### C4B 
result_pre_match %>% merge(matched_data %>% dplyr::select(rn, hetro, subclass), .by="rn") %>% 
mutate(rate=exac_modsev_n/trt_dur) %>% 
  mutate(mean_het=mean(hetro), .by=subclass)%>% 
  dplyr::select(rate, subclass, mean_het, arm_ipd) %>%
  mutate(arm_ipd=if_else(arm_ipd==0, "ICS", "Control")) %>% 
  pivot_wider(names_from = arm_ipd, values_from = rate) %>% 
  mutate(diff=ICS-Control) %>% 
  lm(diff~mean_het, data=.) %>% 
  survival::concordance()
```

##### Validation

```{r}
library(MatchIt)
result_pre_match=result2 %>% 
  mutate(rn=row_number()) %>% 
  cbind.data.frame("exac_modsev_n"=test$exac_modsev_n)

set.seed(124)
min_size <- result_pre_match %>%
  group_by(arm_ipd) %>%
  summarise(n = n()) %>%
  pull(n) %>%
  min()

result_balanced <- result_pre_match %>%
  group_by(arm_ipd) %>%
  sample_n(min_size, replace = F) %>%
  ungroup() %>% 
  arrange(rn)

result_excess=result_balanced %>% 
  mutate(excess=exac_modsev_n/trt_dur-exp(homo))


# Perform full matching
m.out <- matchit(arm_ipd ~ hetro,
                 data = result_excess,
                 method = "optimal",
                 ratio = 1,
                 replace = FALSE)

# Get matched data with subclass info
matched_data <- match.data(m.out)

# Show who is matched together (by subclass)
matched_groups <- matched_data %>%
  dplyr::select(subclass, arm_ipd, everything()) %>%
  arrange(subclass)%>% 
  mutate(arm_ipd=if_else(arm_ipd==0, "ICS", "Control"))

matched_groups %>%
  ggplot(aes(x = arm_ipd, y = hetro, group = subclass, colour=arm_ipd)) +
  geom_line(color = "black") +
  geom_point()+
  labs(colour="Arm")+
  theme_classic()

### C4B 
result_pre_match %>% merge(matched_data %>% dplyr::select(rn, hetro, subclass), .by="rn") %>% 
mutate(rate=exac_modsev_n/trt_dur) %>% 
  mutate(mean_het=mean(hetro), .by=subclass)%>% 
  dplyr::select(rate, subclass, mean_het, arm_ipd) %>%
  mutate(arm_ipd=if_else(arm_ipd==0, "ICS", "Control")) %>% 
  pivot_wider(names_from = arm_ipd, values_from = rate) %>% 
  mutate(diff=ICS-Control) %>% 
  lm(diff~mean_het, data=.) %>% 
  survival::concordance()
```
