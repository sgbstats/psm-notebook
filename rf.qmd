---
title: "Random Forests"
bibliography: references.bib
---

Random forest needs to have complete data and ones where there it is missing it seems to want to impute with mean impution. I really don't like this approach. @tang2017

Takes sqrt(n) of the variables each time and builds a decision tree from those variables and then takes the average from all of the trees (normally 100)

I am using the [regression imputation](ri) to build out the incomplete data.

Major question about interaction. I think that we would have add an interaction variable into the datasets but then theoretically it should only be in models when both of the arm and eos (eg) were both in the tree.

We are using a T-learner

```{r, echo=FALSE, message=FALSE, warning=FALSE}
load("C:\\Users\\mbbx4sb5\\Dropbox (The University of Manchester)\\00_ICS_RECODE_Shared\\data/study_data.RDa")
```

```{r,message=FALSE, warning=FALSE, eval=F}


library(randomForest)
library(tidyverse)



ddm=study_data$EFFECT$ddm %>% 
  dplyr::select(usubjid, paramcd, aval) %>% 
  pivot_wider(names_from=paramcd, values_from=aval) %>% 
  dplyr::select(-BACT)

ad=study_data$EFFECT$ad %>% 
  dplyr::select(usubjid, arm_ipd, ics_dose, ics_dose_24, trt_dur, age_imp, ics_bl, sex, cat_bl,
                fev1_bl, fev1percent_bl, fvc_bl, fev1fvc_bl, laba_bl, lama_bl, comorb_tot_bl, eos_bl, 
                eos_pc_bl, reversibility_bl, smoking_bl, exac_bl, gold_grp, gold_stage, exac_modsev_n)
model="rate~."
model=as.formula(model)
data=merge(ad, ddm, by="usubjid") %>%
  filter(trt_dur>0.5) %>% 
  #dplyr::mutate_at(c("exac_bl", "fev1_bl"),~ifelse(sample(c(TRUE, FALSE), size = length(.), replace = TRUE, prob = c(0.8, 0.2)),., NA))%>% 
  mutate(interaction=eos_bl*if_else(arm_ipd=="ICS",1,0),
         rate=exac_modsev_n/trt_dur) %>% 
  drop_na(rate)%>% 
  dplyr::select(-trt_dur, -exac_modsev_n, -usubjid) %>% 
  mutate(across(where(is.logical), as.integer))

data2=na.roughfix(data)


data$train=as.logical(rbinom(nrow(data),1, 0.8))

rf=randomForest(formula=model, data=data %>% filter(train) %>% dplyr::select(-train), na.action = na.omit)
varImpPlot(rf)


newdata=data %>% filter(!train) %>% 
  dplyr::select(-train)%>%
  na.roughfix()

z=predict(rf, newdata, se.fit=T)

pred.out=data.frame(actual=newdata$rate,
                    pred=z)

pred.out %>% lm(actual~pred, data=.) %>% survival::concordance()



z1=predict(rf, newdata, predict.all = T)



pred=z1$individual%>% as.data.frame() %>%  mutate(rn=row_number()) %>% 
  pivot_longer(cols=-"rn", values_to="pred", names_to = "tree") %>% 
  summarise(se.fit=sd(pred,na.rm=T), .by="rn") %>% 
  merge(data.frame(pred=z1$aggregate )%>% mutate(rn=row_number()), by="rn")




```

## Thoughts about imputing data

-   na.roughfix, isn't a great option but may have some useful properties like actually wanting to reduce variance of predictor as a penalty for having high levels of incompleteness

-   How we would deal with missing data in the test set may be more tricky.

    -   I think we could use MICE to make n=20ish copies of the data to be predicted and then averaged over the prediction. Could be computationally intensive though (as then you be making 10k predictions.

    -   In practice you could end up having to impute on the client-side which may not be possible

    -   Or you use mean/mode imputation for new predictions.


## Some code

```{r, echo=FALSE, message=FALSE, warning=FALSE}
meta_learner = function(data, strata, formula, algorithm, ...) {
  out = list()
  levels = unique(data[[strata]])
  if (class(formula) != "formula") {
    t = list()
    vars = list()
  }
  for (j in levels) {
    # cat(paste(j, "\n"))
    if (class(formula) == "formula") {
      out[[j]] = algorithm(
        formula = formula,
        data = data |>
          filter(((!!as.name(strata)) == j)) |>
          select(-(!!as.name(strata))),
        ...
      )
      t = terms(formula, data = data)
      vars = attr(t, "term.labels")
    } else {
      out[[j]] = algorithm(
        formula = formula[[j]],
        data = data |>
          filter(((!!as.name(strata)) == j)) |>
          select(-(!!as.name(strata))),
        ...
      )
      t[[j]] = terms(formula[[j]], data = data)
      vars[[j]] = attr(t[[j]], "term.labels")
    }
  }

  out = c(
    out,
    list(
      meta = list("strata" = strata, "levels" = levels),
      terms = formula,
      vars = vars
    )
  )
  structure(
    out,
    class = "meta_learner"
  )
}

predict.meta_learner = function(object, newdata, fn = predict) {
  nd2 <- newdata |> mutate(rn = row_number())
  fit <- (nd2 |> mutate(fit = NA_real_))[0, ]

  for (j in object[["meta"]][["levels"]]) {
    nd3 <- nd2 |> filter(.data[[object[["meta"]][["strata"]]]] == j)

    # determine predictors for this stratum (robust to how meta_learner saved terms/vars)
    vars_needed <- NULL
    if (!is.null(object$vars) && !is.null(object$vars[[j]])) {
      vars_needed <- object$vars[[j]]
    } else if (!is.null(object$terms) && !is.null(object$terms[[j]])) {
      vars_needed <- attr(terms(object$terms[[j]]), "term.labels")
    } else if (inherits(object$terms, "formula")) {
      vars_needed <- attr(terms(object$terms), "term.labels")
    }

    if (is.null(vars_needed)) vars_needed <- character(0)

    # compute complete-case mask for the subset nd3
    cc <- if (length(vars_needed) > 0L) complete.cases(nd3[vars_needed]) else rep(TRUE, nrow(nd3))
    preds <- rep(NA_real_, nrow(nd3))

    if (any(cc)) {
      res <- fn(object[[j]], nd3[cc, , drop = FALSE])

      # normalize different prediction shapes into a numeric vector
      if (is.numeric(res) && length(res) == sum(cc)) {
        preds[cc] <- res
      } else if (is.matrix(res) || is.data.frame(res)) {
        if (ncol(res) >= 2) {
          preds[cc] <- as.numeric(res[, 2])
        } else {
          preds[cc] <- as.numeric(res[, 1])
        }
      } else if (is.factor(res)) {
        preds[cc] <- as.numeric(as.character(res))
      } else {
        preds[cc] <- as.numeric(res)
      }
    }

    fit <- bind_rows(fit, bind_cols(nd3, tibble::tibble(fit = preds)))
  }

  names(fit)[names(fit) == object[["meta"]][["strata"]]] <- object[["meta"]][["strata"]]
  fit <- fit |> arrange(rn) |> dplyr::select(-rn)
  fit$fit
}

```
::: {#refs}
:::